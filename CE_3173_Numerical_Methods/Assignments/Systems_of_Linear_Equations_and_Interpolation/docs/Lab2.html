<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Lab2</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-11-10">
<meta name="DC.source" content="Lab2.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Laboratory Assignment #2: Systems of Linear Equations and Interpolation</a>
</li>
<li>
<a href="#2">Problem 1.1. Partial Pivoting On a Given SLE</a>
</li>
<li>
<a href="#3">Problem 1.2. Solution of SLE with the Gauss-Seidel Method</a>
</li>
<li>
<a href="#4">Problem 1.3. Plot of Solution to SLE</a>
</li>
<li>
<a href="#5">Problem 1.4. Plot of Absolute Approx. Percentage Errors</a>
</li>
<li>
<a href="#6">Problem 1.5. Absolute True Percentage Errors</a>
</li>
<li>
<a href="#7">Problem 2.1 1st-Order Interpolation with Newton&rsquo;s Divided-Differences</a>
</li>
<li>
<a href="#8">Problem 2.2 2nd-Order Interpolation with Newton&rsquo;s Divided-Differences</a>
</li>
<li>
<a href="#9">Problem 2.3 3rd-Order Interpolation with Newton&rsquo;s Divided-Differences</a>
</li>
<li>
<a href="#10">Problem 3.1 1st-order Lagrange Interpolation</a>
</li>
<li>
<a href="#11">Problem 3.2 2nd-order Lagrange Interpolation</a>
</li>
<li>
<a href="#12">Problem 3.3 3rd-order Lagrange Interpolation</a>
</li>
<li>
<a href="#13">Problem 4.1 2nd-order Interpolation via SLE</a>
</li>
<li>
<a href="#14">Problem 4.2 3rd-order Interpolation via SLE</a>
</li>
<li>
<a href="#15">Problem 4.3 7th-order Interpolation via SLE</a>
</li>
<li>
<a href="#16">Problem 4.4 Absolute True Percentage Errors</a>
</li>
</ul>
</div>
<h2 id="1">Laboratory Assignment #2: Systems of Linear Equations and Interpolation</h2>
<pre class="codeinput">
<span class="comment">%Name: Keanu Anderson-Pola</span>
<span class="comment">%UTSA ID: tro893</span>
<span class="comment">%Date: 10/26/2024</span>
</pre>
<h2 id="2">Problem 1.1. Partial Pivoting On a Given SLE</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Define matrix A and vector b:</span>
A = [-1 4 2 0 0; 18 4 -6 -2 2; -3 9 6 -3 21; 0 10 -2 5 2; -1 3 0 -6 2];
b = [30; -68; -117; 23; -23];

<span class="comment">% Augmented Matrix AM:</span>
AM = [A b];

<span class="comment">% Display the initial augmented matrix:</span>
fprintf(<span class="string">'Initial Augmented Matrix [A|b]:\n'</span>);
disp(AM);

<span class="comment">% Manual Row Swaps to make the system diagonally dominant:</span>
<span class="comment">% Swap row 1 with row 2</span>
AM([1 2], :) = AM([2 1], :);
fprintf(<span class="string">'Swapping row 1 with row 2:\n'</span>);
disp(AM);

<span class="comment">% Swap row 2 with row 4</span>
AM([2 4], :) = AM([4 2], :);
fprintf(<span class="string">'Swapping row 2 with row 4:\n'</span>);
disp(AM);

<span class="comment">% Swap row 4 with row 5</span>
AM([4 5], :) = AM([5 4], :);
fprintf(<span class="string">'Swapping row 4 with row 5:\n'</span>);
disp(AM);

<span class="comment">% Finally, swap row 5 with row 3</span>
AM([5 3], :) = AM([3 5], :);
fprintf(<span class="string">'Swapping row 5 with row 3:\n'</span>);
disp(AM);

<span class="comment">% Final augmented matrix after all manual swaps:</span>
disp(<span class="string">'Final Augmented Matrix after Partial Pivoting:'</span>);
disp(AM);
</pre>
<pre class="codeoutput">Initial Augmented Matrix [A|b]:
    -1     4     2     0     0    30
    18     4    -6    -2     2   -68
    -3     9     6    -3    21  -117
     0    10    -2     5     2    23
    -1     3     0    -6     2   -23

Swapping row 1 with row 2:
    18     4    -6    -2     2   -68
    -1     4     2     0     0    30
    -3     9     6    -3    21  -117
     0    10    -2     5     2    23
    -1     3     0    -6     2   -23

Swapping row 2 with row 4:
    18     4    -6    -2     2   -68
     0    10    -2     5     2    23
    -3     9     6    -3    21  -117
    -1     4     2     0     0    30
    -1     3     0    -6     2   -23

Swapping row 4 with row 5:
    18     4    -6    -2     2   -68
     0    10    -2     5     2    23
    -3     9     6    -3    21  -117
    -1     3     0    -6     2   -23
    -1     4     2     0     0    30

Swapping row 5 with row 3:
    18     4    -6    -2     2   -68
     0    10    -2     5     2    23
    -1     4     2     0     0    30
    -1     3     0    -6     2   -23
    -3     9     6    -3    21  -117

Final Augmented Matrix after Partial Pivoting:
    18     4    -6    -2     2   -68
     0    10    -2     5     2    23
    -1     4     2     0     0    30
    -1     3     0    -6     2   -23
    -3     9     6    -3    21  -117

</pre>
<h2 id="3">Problem 1.2. Solution of SLE with the Gauss-Seidel Method</h2>
<pre class="codeinput">
<span class="comment">%Clear screen contents.</span>
clc

<span class="comment">% Extract matrix A and vector b from the augmented matrix:</span>
A = AM(:, 1:end-1);
b = AM(:, end);

<span class="comment">% Initial guess for the solution vector:</span>
x = [10; -5; -5; -8; 20];

<span class="comment">% Number of rows and columns:</span>
[m, n] = size(A);

<span class="comment">% Create auxiliary matrix and vectors:</span>
c = zeros(m, n);
d = zeros(m, 1);

<span class="comment">% Define initial error, tolerance, and initial iteration:</span>
ea = 100;
tol = 2;  <span class="comment">% 2% tolerance</span>
iter = 1;

<span class="comment">% Initialize arrays to store the values at each iteration for each unknown</span>
<span class="comment">% (for 1.3)</span>
x1_vals = [];
x2_vals = [];
x3_vals = [];
x4_vals = [];
x5_vals = [];

<span class="comment">% Initialize arrays to store absolute approximate percentage errors at each</span>
<span class="comment">% iteration (for 1.4)</span>
x1_errors = [];
x2_errors = [];
x3_errors = [];
x4_errors = [];
x5_errors = [];

<span class="comment">% Gauss-Seidel iterative method:</span>
<span class="keyword">while</span> ea &gt; tol
    <span class="keyword">for</span> i = 1:n
        <span class="comment">% Compute vector of coefficients:</span>
        d(i) = b(i) / A(i, i);

        <span class="comment">% Compute coefficient matrix "c":</span>
        <span class="keyword">for</span> j = 1:m
            <span class="keyword">if</span> i == j
                c(i, j) = 0;  <span class="comment">% Diagonal of matrix "c" is zeros</span>
            <span class="keyword">else</span>
                c(i, j) = A(i, j) / A(i, i);  <span class="comment">% Non-diagonal elements</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Calculate new solution:</span>
        x_new(i) = d(i) - c(i, :) * x(:);

        <span class="comment">% Calculate the absolute approximate percentage error:</span>
        ea_vect(i) = abs((x_new(i) - x(i)) / x_new(i) * 100);

        <span class="comment">% Update the solution vector:</span>
        x(i) = x_new(i);
    <span class="keyword">end</span>

    <span class="comment">% Store the current values of x1, x2, x3, x4, x5 at this iteration:</span>
    <span class="comment">% (for 1.3)</span>
    x1_vals = [x1_vals, x(1)];
    x2_vals = [x2_vals, x(2)];
    x3_vals = [x3_vals, x(3)];
    x4_vals = [x4_vals, x(4)];
    x5_vals = [x5_vals, x(5)];

    <span class="comment">% Store the current absolute approximate percentage errors:</span>
    <span class="comment">% (for 1.4)</span>
    x1_errors = [x1_errors, ea_vect(1)];
    x2_errors = [x2_errors, ea_vect(2)];
    x3_errors = [x3_errors, ea_vect(3)];
    x4_errors = [x4_errors, ea_vect(4)];
    x5_errors = [x5_errors, ea_vect(5)];

    <span class="comment">% Determine the maximum error across all unknowns:</span>
    ea = max(ea_vect);

    <span class="comment">% Print only the iteration number and max error:</span>
    fprintf(<span class="string">'Iteration #%d Max EA: %.4f\n'</span>, iter, ea)

    <span class="comment">% Update iteration counter:</span>
    iter = iter + 1;
<span class="keyword">end</span>

<span class="comment">% Display the final solution vector:</span>
disp(<span class="string">'Final solution vector x:'</span>);
disp(x);
</pre>
<pre class="codeoutput">Iteration #1 Max EA: 484.6154
Iteration #2 Max EA: 1598.0968
Iteration #3 Max EA: 710.1195
Iteration #4 Max EA: 191.7027
Iteration #5 Max EA: 1157.7084
Iteration #6 Max EA: 80.0327
Iteration #7 Max EA: 26.3332
Iteration #8 Max EA: 4.1930
Iteration #9 Max EA: 0.2165
Final solution vector x:
   -1.1115
    3.8954
    6.6535
    3.0099
   -8.8707

</pre>
<h2 id="4">Problem 1.3. Plot of Solution to SLE</h2>
<pre class="codeinput">
<span class="comment">%Close all figures.</span>
close <span class="string">all</span>

<span class="comment">% Plot the results from the Gauss-Seidel iterations</span>
iterations = 1:(iter-1);  <span class="comment">% Iteration numbers (from Gauss-Seidel loop)</span>

<span class="comment">% Plotting the results:</span>
figure;
plot(iterations, x1_vals, <span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 2); hold <span class="string">on</span>;
plot(iterations, x2_vals, <span class="string">'-g'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x3_vals, <span class="string">'-b'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x4_vals, <span class="string">'-m'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x5_vals, <span class="string">'-k'</span>, <span class="string">'LineWidth'</span>, 2);

<span class="comment">% Add labels, grid, and legend</span>
xlabel(<span class="string">'Iterations'</span>);
ylabel(<span class="string">'Values of Unknowns'</span>);
grid <span class="string">on</span>;
legend(<span class="string">'x1'</span>, <span class="string">'x2'</span>, <span class="string">'x3'</span>, <span class="string">'x4'</span>, <span class="string">'x5'</span>);
title(<span class="string">'Plot of Solution to SLE'</span>);

<span class="comment">% Final plot setup:</span>
hold <span class="string">off</span>;
</pre>
<img vspace="5" hspace="5" src="Lab2_01.png" alt=""> <h2 id="5">Problem 1.4. Plot of Absolute Approx. Percentage Errors</h2>
<pre class="codeinput">
<span class="comment">%Close all figures.</span>
close <span class="string">all</span>

<span class="comment">% Plotting the results:</span>
figure;
plot(iterations, x1_errors, <span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 2); hold <span class="string">on</span>;
plot(iterations, x2_errors, <span class="string">'-g'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x3_errors, <span class="string">'-b'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x4_errors, <span class="string">'-m'</span>, <span class="string">'LineWidth'</span>, 2);
plot(iterations, x5_errors, <span class="string">'-k'</span>, <span class="string">'LineWidth'</span>, 2);

<span class="comment">% Add labels, grid, and legend</span>
xlabel(<span class="string">'Iterations'</span>);
ylabel(<span class="string">'Absolute Approximate Percentage Errors'</span>);
grid <span class="string">on</span>;
legend(<span class="string">'x1 Error'</span>, <span class="string">'x2 Error'</span>, <span class="string">'x3 Error'</span>, <span class="string">'x4 Error'</span>, <span class="string">'x5 Error'</span>);
title(<span class="string">'Plot of Absolute Approx. Percentage Errors'</span>);

<span class="comment">% Final plot setup:</span>
hold <span class="string">off</span>;
</pre>
<img vspace="5" hspace="5" src="Lab2_02.png" alt=""> <h2 id="6">Problem 1.5. Absolute True Percentage Errors</h2>
<pre class="codeinput">
<span class="comment">%Close all figures.</span>
close <span class="string">all</span>

<span class="comment">% MATLAB's built-in function</span>
x_true = A \ b;

<span class="comment">% Display the true solution</span>
disp(<span class="string">'true x:'</span>);
disp(x_true);

<span class="comment">% Compute the absolute true percentage errors for each variable</span>
true_error_x1 = abs((x_true(1) - x1_vals(end)) / x_true(1)) * 100;
true_error_x2 = abs((x_true(2) - x2_vals(end)) / x_true(2)) * 100;
true_error_x3 = abs((x_true(3) - x3_vals(end)) / x_true(3)) * 100;
true_error_x4 = abs((x_true(4) - x4_vals(end)) / x_true(4)) * 100;
true_error_x5 = abs((x_true(5) - x5_vals(end)) / x_true(5)) * 100;

<span class="comment">% Display the true percentage errors:</span>
fprintf(<span class="string">'Absolute True Percentage Error for x1: %.4f%%\n'</span>, true_error_x1);
fprintf(<span class="string">'Absolute True Percentage Error for x2: %.4f%%\n'</span>, true_error_x2);
fprintf(<span class="string">'Absolute True Percentage Error for x3: %.4f%%\n'</span>, true_error_x3);
fprintf(<span class="string">'Absolute True Percentage Error for x4: %.4f%%\n'</span>, true_error_x4);
fprintf(<span class="string">'Absolute True Percentage Error for x5: %.4f%%\n'</span>, true_error_x5);
</pre>
<pre class="codeoutput">true x:
   -1.1077
    3.8986
    6.6490
    3.0105
   -8.8701

Absolute True Percentage Error for x1: 0.3400%
Absolute True Percentage Error for x2: 0.0822%
Absolute True Percentage Error for x3: 0.0680%
Absolute True Percentage Error for x4: 0.0219%
Absolute True Percentage Error for x5: 0.0062%
</pre>
<h2 id="7">Problem 2.1 1st-Order Interpolation with Newton&rsquo;s Divided-Differences</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data</span>
v = [0, 3, 4, 6, 10];
P = [0, 45, 156, 643, 2720];

<span class="comment">% Calculation of coefficients (1st order)</span>
b0 = P(4);
b1 = (P(5) - b0) / (v(5) - v(4));

<span class="comment">% Estimate power at v = 9</span>
v_est = 9;
P_est = b0 + b1 * (v_est - v(4));

<span class="comment">% Display the estimated power</span>
fprintf(<span class="string">'Estimated Power at v = %.2f m/s using 1st-order interpolation: %.2f kW\n'</span>, v_est, P_est);

<span class="comment">% Plot raw data</span>
figure;
plot(v, P, <span class="string">'o'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'b'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>); hold <span class="string">on</span>;

<span class="comment">% Plot estimated value at v = 9</span>
plot(v_est, P_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);

<span class="comment">% Plot the interpolating polynomial</span>
v_full = linspace(0, 10, 100);  <span class="comment">% Full range of wind speeds from 0 to 10</span>
P_interp = b0 + b1 * (v_full - v(4));  <span class="comment">% 1st-order polynomial over the full range</span>
plot(v_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);  <span class="comment">% Plot the interpolation line</span>

<span class="comment">% Add labels, title, and grid</span>
xlabel(<span class="string">'Wind Speed v (m/s)'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'Electrical Power P(v) (kW)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'1st-Order Interpolation with Newton&rsquo;s Divided-Differences'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;

hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated Power at v = 9.00 m/s using 1st-order interpolation: 2200.75 kW
</pre>
<img vspace="5" hspace="5" src="Lab2_03.png" alt=""> <h2 id="8">Problem 2.2 2nd-Order Interpolation with Newton&rsquo;s Divided-Differences</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data</span>
v = [0, 3, 4, 6, 10];
P = [0, 45, 156, 643, 2720];

<span class="comment">% 2nd-order Newton's divided-difference coefficients</span>
b0 = P(3);
b1 = (P(4) - P(3)) / (v(4) - v(3));  <span class="comment">% 1st-order divided difference between v3 and v4</span>
b2 = ((P(5) - P(4)) / (v(5) - v(4)) - b1) / (v(5) - v(3));  <span class="comment">% 2nd-order divided difference</span>

<span class="comment">% Estimate power at v = 9</span>
v_est = 9;
P_est = b0 + b1 * (v_est - v(3)) + b2 * (v_est - v(3)) * (v_est - v(4));

<span class="comment">% Display the estimated power</span>
fprintf(<span class="string">'Estimated Power at v = %.2f m/s using 2nd-order interpolation: %.2f kW\n'</span>, v_est, P_est);

<span class="comment">% Plot raw data</span>
figure;
plot(v, P, <span class="string">'o'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'b'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>); hold <span class="string">on</span>;

<span class="comment">% Plot estimated value at v = 9</span>
plot(v_est, P_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);

<span class="comment">% Plot the interpolating polynomial</span>
v_full = linspace(0, 10, 100);  <span class="comment">% Full range of wind speeds from 0 to 10</span>
P_interp = b0 + b1 * (v_full - v(3)) + b2 * (v_full - v(3)) .* (v_full - v(4));  <span class="comment">% 2nd-order polynomial</span>
plot(v_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);  <span class="comment">% Plot the interpolation line</span>

<span class="comment">% Add labels, title, and grid</span>
xlabel(<span class="string">'Wind Speed v (m/s)'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'Electrical Power P(v) (kW)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'2nd-Order Interpolation with Newton&rsquo;s Divided-Differences'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;

hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated Power at v = 9.00 m/s using 2nd-order interpolation: 2062.88 kW
</pre>
<img vspace="5" hspace="5" src="Lab2_04.png" alt=""> <h2 id="9">Problem 2.3 3rd-Order Interpolation with Newton&rsquo;s Divided-Differences</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data</span>
v = [0, 3, 4, 6, 10];
P = [0, 45, 156, 643, 2720];

<span class="comment">% 3rd-order Newton's divided-difference coefficients</span>
b0 = P(2);  <span class="comment">% P(v2) corresponding to v = 3</span>
b1 = (P(3) - P(2)) / (v(3) - v(2));  <span class="comment">% 1st-order divided difference between v2 and v3</span>
b2 = ((P(4) - P(3)) / (v(4) - v(3)) - b1) / (v(4) - v(2));  <span class="comment">% 2nd-order divided difference</span>
b3 = (((P(5) - P(4)) / (v(5) - v(4)) - (P(4) - P(3)) / (v(4) - v(3))) / (v(5) - v(3)) - b2) / (v(5) - v(2));  <span class="comment">% 3rd-order divided difference</span>

<span class="comment">% Estimate power at v = 9</span>
v_est = 9;
P_est = b0 + b1 * (v_est - v(2)) + b2 * (v_est - v(2)) * (v_est - v(3)) + b3 * (v_est - v(2)) * (v_est - v(3)) * (v_est - v(4));

<span class="comment">% Display the estimated power</span>
fprintf(<span class="string">'Estimated Power at v = %.2f m/s using 3rd-order interpolation: %.2f kW\n'</span>, v_est, P_est);

<span class="comment">% Plot raw data</span>
figure;
plot(v, P, <span class="string">'o'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'b'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>); hold <span class="string">on</span>;

<span class="comment">% Plot estimated value at v = 9</span>
plot(v_est, P_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);

<span class="comment">% Plot the interpolating polynomial</span>
v_full = linspace(0, 10, 100);  <span class="comment">% Full range of wind speeds from 0 to 10</span>
P_interp = b0 + b1 * (v_full - v(2)) + b2 * (v_full - v(2)) .* (v_full - v(3)) + b3 * (v_full - v(2)) .* (v_full - v(3)) .* (v_full - v(4));
plot(v_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);  <span class="comment">% Plot the interpolation line</span>

<span class="comment">% Add labels, title, and grid</span>
xlabel(<span class="string">'Wind Speed v (m/s)'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'Electrical Power P(v) (kW)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'3rd-Order Interpolation with Newton&rsquo;s Divided-Differences'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;

hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated Power at v = 9.00 m/s using 3rd-order interpolation: 2059.04 kW
</pre>
<img vspace="5" hspace="5" src="Lab2_05.png" alt=""> <h2 id="10">Problem 3.1 1st-order Lagrange Interpolation</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data set</span>
x = [5, 12];
y = [1.609, 2.485];

<span class="comment">% Evaluation of Lagrange polynomial for x = 10</span>
x_est = 10;
y_est = (x_est - x(2)) / (x(1) - x(2)) * y(1) + <span class="keyword">...</span>
        (x_est - x(1)) / (x(2) - x(1)) * y(2);

<span class="comment">% Display the estimated value</span>
fprintf(<span class="string">'Estimated y at x = %.2f using 1st-order Lagrange interpolation: %.4f\n'</span>, x_est, y_est);

<span class="comment">% Plot</span>
plot(x, y, <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2); hold <span class="string">on</span>;
plot(x_est, y_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) ./ (x(1) - x(2)) * y(1) + <span class="keyword">...</span>
           (x_full - x(1)) ./ (x(2) - x(1)) * y(2);
plot(x_full, y_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'x'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'y(x)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'1st-Order Lagrange Interpolation'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated y at x = 10.00 using 1st-order Lagrange interpolation: 2.2347
</pre>
<img vspace="5" hspace="5" src="Lab2_06.png" alt=""> <h2 id="11">Problem 3.2 2nd-order Lagrange Interpolation</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data set</span>
x = [5, 12, 16];
y = [1.609, 2.485, 2.773];

<span class="comment">% Evaluation of Lagrange polynomial for x = 10</span>
x_est = 10;
y_est = (x_est - x(2)) * (x_est - x(3)) / ((x(1) - x(2)) * (x(1) - x(3))) * y(1) + <span class="keyword">...</span>
        (x_est - x(1)) * (x_est - x(3)) / ((x(2) - x(1)) * (x(2) - x(3))) * y(2) + <span class="keyword">...</span>
        (x_est - x(1)) * (x_est - x(2)) / ((x(3) - x(1)) * (x(3) - x(2))) * y(3);

<span class="comment">% Display the estimated value</span>
fprintf(<span class="string">'Estimated y at x = %.2f using 2nd-order Lagrange interpolation: %.4f\n'</span>, x_est, y_est);

<span class="comment">% Plot</span>
plot(x, y, <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2); hold <span class="string">on</span>;
plot(x_est, y_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) .* (x_full - x(3)) ./ ((x(1) - x(2)) * (x(1) - x(3))) * y(1) + <span class="keyword">...</span>
           (x_full - x(1)) .* (x_full - x(3)) ./ ((x(2) - x(1)) * (x(2) - x(3))) * y(2) + <span class="keyword">...</span>
           (x_full - x(1)) .* (x_full - x(2)) ./ ((x(3) - x(1)) * (x(3) - x(2))) * y(3);
plot(x_full, y_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'x'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'y(x)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'2nd-Order Lagrange Interpolation'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated y at x = 10.00 using 2nd-order Lagrange interpolation: 2.2830
</pre>
<img vspace="5" hspace="5" src="Lab2_07.png" alt=""> <h2 id="12">Problem 3.3 3rd-order Lagrange Interpolation</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Data set</span>
x = [5, 12, 16, 20];
y = [1.609, 2.485, 2.773, 2.996];

<span class="comment">% Evaluation of Lagrange polynomial for x = 10</span>
x_est = 10;
y_est = (x_est - x(2)) * (x_est - x(3)) * (x_est - x(4)) / ((x(1) - x(2)) * (x(1) - x(3)) * (x(1) - x(4))) * y(1) + <span class="keyword">...</span>
        (x_est - x(1)) * (x_est - x(3)) * (x_est - x(4)) / ((x(2) - x(1)) * (x(2) - x(3)) * (x(2) - x(4))) * y(2) + <span class="keyword">...</span>
        (x_est - x(1)) * (x_est - x(2)) * (x_est - x(4)) / ((x(3) - x(1)) * (x(3) - x(2)) * (x(3) - x(4))) * y(3) + <span class="keyword">...</span>
        (x_est - x(1)) * (x_est - x(2)) * (x_est - x(3)) / ((x(4) - x(1)) * (x(4) - x(2)) * (x(4) - x(3))) * y(4);

<span class="comment">% Display the estimated value</span>
fprintf(<span class="string">'Estimated y at x = %.2f using 3rd-order Lagrange interpolation: %.4f\n'</span>, x_est, y_est);

<span class="comment">% Plot</span>
plot(x, y, <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2); hold <span class="string">on</span>;
plot(x_est, y_est, <span class="string">'xr'</span>, <span class="string">'LineWidth'</span>, 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) .* (x_full - x(3)) .* (x_full - x(4)) ./ ((x(1) - x(2)) * (x(1) - x(3)) * (x(1) - x(4))) * y(1) + <span class="keyword">...</span>
           (x_full - x(1)) .* (x_full - x(3)) .* (x_full - x(4)) ./ ((x(2) - x(1)) * (x(2) - x(3)) * (x(2) - x(4))) * y(2) + <span class="keyword">...</span>
           (x_full - x(1)) .* (x_full - x(2)) .* (x_full - x(4)) ./ ((x(3) - x(1)) * (x(3) - x(2)) * (x(3) - x(4))) * y(3) + <span class="keyword">...</span>
           (x_full - x(1)) .* (x_full - x(2)) .* (x_full - x(3)) ./ ((x(4) - x(1)) * (x(4) - x(2)) * (x(4) - x(3))) * y(4);
plot(x_full, y_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'x'</span>, <span class="string">'FontSize'</span>, 12);
ylabel(<span class="string">'y(x)'</span>, <span class="string">'FontSize'</span>, 12);
title(<span class="string">'3rd-Order Lagrange Interpolation'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
hold <span class="string">off</span>;
</pre>
<pre class="codeoutput">Estimated y at x = 10.00 using 3rd-order Lagrange interpolation: 2.2942
</pre>
<img vspace="5" hspace="5" src="Lab2_08.png" alt=""> <h2 id="13">Problem 4.1 2nd-order Interpolation via SLE</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Given Data (t P(t))</span>
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
<span class="comment">% Point of interest:</span>
t_est = 18.5;
<span class="comment">% Initialization of order of interpolation</span>
Order = 2;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

<span class="comment">% Perform interpolation</span>
<span class="keyword">for</span> k = Order:size(A,1)
    <span class="keyword">if</span> A(k,1) &gt;= t_est
        <span class="comment">% Formulation of coefficient matrix R and vector of constants b</span>
        <span class="keyword">for</span> i = 1:Order+1
            <span class="keyword">for</span> j = 1:Order+1
                R(i,j) = A(k+1-i,1)^(Order+1-j);
            <span class="keyword">end</span>
            b(i) = A(k+1-i,2);
        <span class="keyword">end</span>
        <span class="comment">% Solution of system of equations via the inverse matrix</span>
        coef = R\b;

        <span class="comment">% Evaluation of interpolating polynomial</span>
        <span class="keyword">for</span> i = 1:size(coef,1)
            f = f + coef(i)*t_est^(Order+1-i);
        <span class="keyword">end</span>

        fprintf(<span class="string">'P(%.2f) = %.4f\n'</span>, t_est, f);
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plot</span>
plot(t_est, f, <span class="string">'rx'</span>, <span class="string">'LineWidth'</span>, 10); hold <span class="string">on</span>;
plot(A(:,1), A(:,2), <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
<span class="keyword">for</span> p = 1:length(t_full)
    <span class="keyword">for</span> i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
plot(t_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1);
xlabel(<span class="string">'Time t (s)'</span>);
ylabel(<span class="string">'Position P(t) (cm)'</span>);
title(<span class="string">'2nd-order Interpolation via SLE'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
</pre>
<pre class="codeoutput">P(18.50) = 0.9788
</pre>
<img vspace="5" hspace="5" src="Lab2_09.png" alt=""> <h2 id="14">Problem 4.2 3rd-order Interpolation via SLE</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Given Data (t P(t))</span>
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
<span class="comment">% Point of interest:</span>
t_est = 18.5;
<span class="comment">% Initialization of order of interpolation</span>
Order = 3;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

<span class="comment">% Perform interpolation</span>
<span class="keyword">for</span> k = Order:size(A,1)
    <span class="keyword">if</span> A(k,1) &gt;= t_est
        <span class="comment">% Form matrix R and vector b</span>
        <span class="keyword">for</span> i = 1:Order+1
            <span class="keyword">for</span> j = 1:Order+1
                R(i,j) = A(k+1-i,1)^(Order+1-j);
            <span class="keyword">end</span>
            b(i) = A(k+1-i,2);
        <span class="keyword">end</span>
        <span class="comment">% Solution of system of equations via the inverse matrix</span>
        coef = R\b;

        <span class="comment">% Evaluation of interpolating polynomial</span>
        <span class="keyword">for</span> i = 1:size(coef,1)
            f = f + coef(i)*t_est^(Order+1-i);
        <span class="keyword">end</span>

        fprintf(<span class="string">'P(%.2f) = %.4f\n'</span>, t_est, f);
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plot</span>
plot(t_est, f, <span class="string">'rx'</span>, <span class="string">'LineWidth'</span>, 10); hold <span class="string">on</span>;
plot(A(:,1), A(:,2), <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
<span class="keyword">for</span> p = 1:length(t_full)
    <span class="keyword">for</span> i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
plot(t_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1);
legend(<span class="string">'Interpolated Value'</span>, <span class="string">'Given Data'</span>, <span class="string">'Interpolating Polynomial'</span>);
xlabel(<span class="string">'Time t (s)'</span>);
ylabel(<span class="string">'Position P(t) (cm)'</span>);
title(<span class="string">'3rd-order Interpolation via SLE'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
</pre>
<pre class="codeoutput">P(18.50) = 1.3134
</pre>
<img vspace="5" hspace="5" src="Lab2_10.png" alt=""> <h2 id="15">Problem 4.3 7th-order Interpolation via SLE</h2>
<pre class="codeinput">
<span class="comment">%Clear previous workspace, screen, and close all figures:</span>
clear
clc
close <span class="string">all</span>

<span class="comment">% Given Data (t P(t))</span>
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
<span class="comment">% Point of interest:</span>
t_est = 18.5;
<span class="comment">% Initialization of order of interpolation</span>
Order = 7;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

<span class="comment">% Formulation of coefficient matrix R and vector of constants b</span>
<span class="keyword">for</span> i = 1:Order+1
    <span class="keyword">for</span> j = 1:Order+1
        R(i,j) = A(i,1)^(Order+1-j);
    <span class="keyword">end</span>
    b(i) = A(i,2);
<span class="keyword">end</span>

<span class="comment">% Solution of system of equations via the inverse matrix</span>
coef = R\b;

<span class="comment">% Evaluation of interpolating polynomial</span>
<span class="keyword">for</span> i = 1:size(coef,1)
    f = f + coef(i)*t_est^(Order+1-i);
<span class="keyword">end</span>
fprintf(<span class="string">'P(%.2f) = %.4f\n'</span>, t_est, f);

<span class="comment">% Plot</span>
plot(t_est, f, <span class="string">'rx'</span>, <span class="string">'LineWidth'</span>, 10); hold <span class="string">on</span>;
plot(A(:,1), A(:,2), <span class="string">'ob'</span>, <span class="string">'LineWidth'</span>, 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
<span class="keyword">for</span> p = 1:length(t_full)
    <span class="keyword">for</span> i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
plot(t_full, P_interp, <span class="string">'--k'</span>, <span class="string">'LineWidth'</span>, 1);
legend(<span class="string">'Interpolated Value'</span>, <span class="string">'Given Data'</span>, <span class="string">'Interpolating Polynomial'</span>);
xlabel(<span class="string">'Time t (s)'</span>);
ylabel(<span class="string">'Position P(t) (cm)'</span>);
title(<span class="string">'7th-order Interpolation via SLE'</span>, <span class="string">'FontSize'</span>, 12);
grid <span class="string">on</span>;
</pre>
<pre class="codeoutput">P(18.50) = 1.1184
</pre>
<img vspace="5" hspace="5" src="Lab2_11.png" alt=""> <h2 id="16">Problem 4.4 Absolute True Percentage Errors</h2>
<pre class="codeinput">
<span class="comment">%Close all figures.</span>
close <span class="string">all</span>

<span class="comment">% True value</span>
P_true = 1.15;

<span class="comment">% Estimates from Problems 4.1, 4.2, and 4.3</span>
P_4_1 = 0.9788;
P_4_2 = 1.3134;
P_4_3 = 1.1184;

<span class="comment">% Calculate absolute true percentage errors</span>
error_4_1 = abs((P_true - P_4_1) / P_true) * 100;
error_4_2 = abs((P_true - P_4_2) / P_true) * 100;
error_4_3 = abs((P_true - P_4_3) / P_true) * 100;

<span class="comment">% Display the errors</span>
fprintf(<span class="string">'Absolute True Percentage Error for Problem 4.1: %.2f%%\n'</span>, error_4_1);
fprintf(<span class="string">'Absolute True Percentage Error for Problem 4.2: %.2f%%\n'</span>, error_4_2);
fprintf(<span class="string">'Absolute True Percentage Error for Problem 4.3: %.2f%%\n'</span>, error_4_3);
</pre>
<pre class="codeoutput">Absolute True Percentage Error for Problem 4.1: 14.89%
Absolute True Percentage Error for Problem 4.2: 14.21%
Absolute True Percentage Error for Problem 4.3: 2.75%
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Laboratory Assignment #2: Systems of Linear Equations and Interpolation
%Name: Keanu Anderson-Pola
%UTSA ID: tro893
%Date: 10/26/2024

%% Problem 1.1. Partial Pivoting On a Given SLE
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Define matrix A and vector b:
A = [-1 4 2 0 0; 18 4 -6 -2 2; -3 9 6 -3 21; 0 10 -2 5 2; -1 3 0 -6 2];
b = [30; -68; -117; 23; -23];

% Augmented Matrix AM:
AM = [A b];

% Display the initial augmented matrix:
fprintf('Initial Augmented Matrix [A|b]:\n');
disp(AM);

% Manual Row Swaps to make the system diagonally dominant:
% Swap row 1 with row 2
AM([1 2], :) = AM([2 1], :);
fprintf('Swapping row 1 with row 2:\n');
disp(AM);

% Swap row 2 with row 4
AM([2 4], :) = AM([4 2], :);
fprintf('Swapping row 2 with row 4:\n');
disp(AM);

% Swap row 4 with row 5
AM([4 5], :) = AM([5 4], :);
fprintf('Swapping row 4 with row 5:\n');
disp(AM);

% Finally, swap row 5 with row 3
AM([5 3], :) = AM([3 5], :);
fprintf('Swapping row 5 with row 3:\n');
disp(AM);

% Final augmented matrix after all manual swaps:
disp('Final Augmented Matrix after Partial Pivoting:');
disp(AM);

%% Problem 1.2. Solution of SLE with the Gauss-Seidel Method
%Clear screen contents.
clc

% Extract matrix A and vector b from the augmented matrix:
A = AM(:, 1:end-1);
b = AM(:, end);

% Initial guess for the solution vector:
x = [10; -5; -5; -8; 20];  

% Number of rows and columns:
[m, n] = size(A);

% Create auxiliary matrix and vectors:
c = zeros(m, n); 
d = zeros(m, 1);

% Define initial error, tolerance, and initial iteration:
ea = 100;
tol = 2;  % 2% tolerance
iter = 1;

% Initialize arrays to store the values at each iteration for each unknown
% (for 1.3)
x1_vals = [];  
x2_vals = [];  
x3_vals = [];  
x4_vals = []; 
x5_vals = []; 

% Initialize arrays to store absolute approximate percentage errors at each
% iteration (for 1.4)
x1_errors = [];
x2_errors = [];
x3_errors = [];
x4_errors = [];
x5_errors = [];

% Gauss-Seidel iterative method:
while ea > tol
    for i = 1:n
        % Compute vector of coefficients:
        d(i) = b(i) / A(i, i);
        
        % Compute coefficient matrix "c":
        for j = 1:m
            if i == j
                c(i, j) = 0;  % Diagonal of matrix "c" is zeros
            else
                c(i, j) = A(i, j) / A(i, i);  % Non-diagonal elements
            end
        end
        
        % Calculate new solution:
        x_new(i) = d(i) - c(i, :) * x(:);
        
        % Calculate the absolute approximate percentage error:
        ea_vect(i) = abs((x_new(i) - x(i)) / x_new(i) * 100);
        
        % Update the solution vector:
        x(i) = x_new(i);
    end
    
    % Store the current values of x1, x2, x3, x4, x5 at this iteration:
    % (for 1.3)
    x1_vals = [x1_vals, x(1)];
    x2_vals = [x2_vals, x(2)];
    x3_vals = [x3_vals, x(3)];
    x4_vals = [x4_vals, x(4)];
    x5_vals = [x5_vals, x(5)];
    
    % Store the current absolute approximate percentage errors:
    % (for 1.4)
    x1_errors = [x1_errors, ea_vect(1)];
    x2_errors = [x2_errors, ea_vect(2)];
    x3_errors = [x3_errors, ea_vect(3)];
    x4_errors = [x4_errors, ea_vect(4)];
    x5_errors = [x5_errors, ea_vect(5)];
    
    % Determine the maximum error across all unknowns:
    ea = max(ea_vect);
    
    % Print only the iteration number and max error:
    fprintf('Iteration #%d Max EA: %.4f\n', iter, ea)
    
    % Update iteration counter:
    iter = iter + 1;
end

% Display the final solution vector:
disp('Final solution vector x:');
disp(x);



%% Problem 1.3. Plot of Solution to SLE
%Close all figures.
close all

% Plot the results from the Gauss-Seidel iterations
iterations = 1:(iter-1);  % Iteration numbers (from Gauss-Seidel loop)

% Plotting the results:
figure;
plot(iterations, x1_vals, '-r', 'LineWidth', 2); hold on;
plot(iterations, x2_vals, '-g', 'LineWidth', 2);
plot(iterations, x3_vals, '-b', 'LineWidth', 2);
plot(iterations, x4_vals, '-m', 'LineWidth', 2);
plot(iterations, x5_vals, '-k', 'LineWidth', 2);

% Add labels, grid, and legend
xlabel('Iterations');
ylabel('Values of Unknowns');
grid on;
legend('x1', 'x2', 'x3', 'x4', 'x5');
title('Plot of Solution to SLE');

% Final plot setup:
hold off;


%% Problem 1.4. Plot of Absolute Approx. Percentage Errors
%Close all figures.
close all

% Plotting the results:
figure;
plot(iterations, x1_errors, '-r', 'LineWidth', 2); hold on;
plot(iterations, x2_errors, '-g', 'LineWidth', 2);
plot(iterations, x3_errors, '-b', 'LineWidth', 2);
plot(iterations, x4_errors, '-m', 'LineWidth', 2);
plot(iterations, x5_errors, '-k', 'LineWidth', 2);

% Add labels, grid, and legend
xlabel('Iterations');
ylabel('Absolute Approximate Percentage Errors');
grid on;
legend('x1 Error', 'x2 Error', 'x3 Error', 'x4 Error', 'x5 Error');
title('Plot of Absolute Approx. Percentage Errors');

% Final plot setup:
hold off;



%% Problem 1.5. Absolute True Percentage Errors
%Close all figures.
close all

% MATLAB's built-in function
x_true = A \ b;

% Display the true solution
disp('true x:');
disp(x_true);

% Compute the absolute true percentage errors for each variable
true_error_x1 = abs((x_true(1) - x1_vals(end)) / x_true(1)) * 100;
true_error_x2 = abs((x_true(2) - x2_vals(end)) / x_true(2)) * 100;
true_error_x3 = abs((x_true(3) - x3_vals(end)) / x_true(3)) * 100;
true_error_x4 = abs((x_true(4) - x4_vals(end)) / x_true(4)) * 100;
true_error_x5 = abs((x_true(5) - x5_vals(end)) / x_true(5)) * 100;

% Display the true percentage errors:
fprintf('Absolute True Percentage Error for x1: %.4f%%\n', true_error_x1);
fprintf('Absolute True Percentage Error for x2: %.4f%%\n', true_error_x2);
fprintf('Absolute True Percentage Error for x3: %.4f%%\n', true_error_x3);
fprintf('Absolute True Percentage Error for x4: %.4f%%\n', true_error_x4);
fprintf('Absolute True Percentage Error for x5: %.4f%%\n', true_error_x5);



%% Problem 2.1 1st-Order Interpolation with Newton’s Divided-Differences
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data 
v = [0, 3, 4, 6, 10];  
P = [0, 45, 156, 643, 2720];

% Calculation of coefficients (1st order)
b0 = P(4);  
b1 = (P(5) - b0) / (v(5) - v(4)); 

% Estimate power at v = 9
v_est = 9;
P_est = b0 + b1 * (v_est - v(4));

% Display the estimated power
fprintf('Estimated Power at v = %.2f m/s using 1st-order interpolation: %.2f kW\n', v_est, P_est);

% Plot raw data
figure;
plot(v, P, 'o', 'MarkerEdgeColor', 'b', 'MarkerFaceColor', 'b'); hold on;

% Plot estimated value at v = 9
plot(v_est, P_est, 'xr', 'LineWidth', 10);

% Plot the interpolating polynomial
v_full = linspace(0, 10, 100);  % Full range of wind speeds from 0 to 10
P_interp = b0 + b1 * (v_full - v(4));  % 1st-order polynomial over the full range
plot(v_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);  % Plot the interpolation line

% Add labels, title, and grid 
xlabel('Wind Speed v (m/s)', 'FontSize', 12);
ylabel('Electrical Power P(v) (kW)', 'FontSize', 12);
title('1st-Order Interpolation with Newton’s Divided-Differences', 'FontSize', 12);
grid on;

hold off;


%% Problem 2.2 2nd-Order Interpolation with Newton’s Divided-Differences
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data
v = [0, 3, 4, 6, 10];  
P = [0, 45, 156, 643, 2720];

% 2nd-order Newton's divided-difference coefficients
b0 = P(3);  
b1 = (P(4) - P(3)) / (v(4) - v(3));  % 1st-order divided difference between v3 and v4
b2 = ((P(5) - P(4)) / (v(5) - v(4)) - b1) / (v(5) - v(3));  % 2nd-order divided difference

% Estimate power at v = 9
v_est = 9;
P_est = b0 + b1 * (v_est - v(3)) + b2 * (v_est - v(3)) * (v_est - v(4));

% Display the estimated power
fprintf('Estimated Power at v = %.2f m/s using 2nd-order interpolation: %.2f kW\n', v_est, P_est);

% Plot raw data
figure;
plot(v, P, 'o', 'MarkerEdgeColor', 'b', 'MarkerFaceColor', 'b'); hold on;

% Plot estimated value at v = 9
plot(v_est, P_est, 'xr', 'LineWidth', 10);

% Plot the interpolating polynomial
v_full = linspace(0, 10, 100);  % Full range of wind speeds from 0 to 10
P_interp = b0 + b1 * (v_full - v(3)) + b2 * (v_full - v(3)) .* (v_full - v(4));  % 2nd-order polynomial
plot(v_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);  % Plot the interpolation line

% Add labels, title, and grid
xlabel('Wind Speed v (m/s)', 'FontSize', 12);
ylabel('Electrical Power P(v) (kW)', 'FontSize', 12);
title('2nd-Order Interpolation with Newton’s Divided-Differences', 'FontSize', 12);
grid on;

hold off;




%% Problem 2.3 3rd-Order Interpolation with Newton’s Divided-Differences
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data
v = [0, 3, 4, 6, 10];
P = [0, 45, 156, 643, 2720];

% 3rd-order Newton's divided-difference coefficients
b0 = P(2);  % P(v2) corresponding to v = 3
b1 = (P(3) - P(2)) / (v(3) - v(2));  % 1st-order divided difference between v2 and v3
b2 = ((P(4) - P(3)) / (v(4) - v(3)) - b1) / (v(4) - v(2));  % 2nd-order divided difference
b3 = (((P(5) - P(4)) / (v(5) - v(4)) - (P(4) - P(3)) / (v(4) - v(3))) / (v(5) - v(3)) - b2) / (v(5) - v(2));  % 3rd-order divided difference

% Estimate power at v = 9
v_est = 9;
P_est = b0 + b1 * (v_est - v(2)) + b2 * (v_est - v(2)) * (v_est - v(3)) + b3 * (v_est - v(2)) * (v_est - v(3)) * (v_est - v(4));

% Display the estimated power
fprintf('Estimated Power at v = %.2f m/s using 3rd-order interpolation: %.2f kW\n', v_est, P_est);

% Plot raw data
figure;
plot(v, P, 'o', 'MarkerEdgeColor', 'b', 'MarkerFaceColor', 'b'); hold on;

% Plot estimated value at v = 9
plot(v_est, P_est, 'xr', 'LineWidth', 10);

% Plot the interpolating polynomial
v_full = linspace(0, 10, 100);  % Full range of wind speeds from 0 to 10
P_interp = b0 + b1 * (v_full - v(2)) + b2 * (v_full - v(2)) .* (v_full - v(3)) + b3 * (v_full - v(2)) .* (v_full - v(3)) .* (v_full - v(4));
plot(v_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);  % Plot the interpolation line

% Add labels, title, and grid
xlabel('Wind Speed v (m/s)', 'FontSize', 12);
ylabel('Electrical Power P(v) (kW)', 'FontSize', 12);
title('3rd-Order Interpolation with Newton’s Divided-Differences', 'FontSize', 12);
grid on;

hold off;



%% Problem 3.1 1st-order Lagrange Interpolation
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data set
x = [5, 12];  
y = [1.609, 2.485];

% Evaluation of Lagrange polynomial for x = 10
x_est = 10;
y_est = (x_est - x(2)) / (x(1) - x(2)) * y(1) + ...
        (x_est - x(1)) / (x(2) - x(1)) * y(2);

% Display the estimated value
fprintf('Estimated y at x = %.2f using 1st-order Lagrange interpolation: %.4f\n', x_est, y_est);

% Plot
plot(x, y, 'ob', 'LineWidth', 2); hold on;
plot(x_est, y_est, 'xr', 'LineWidth', 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) ./ (x(1) - x(2)) * y(1) + ...
           (x_full - x(1)) ./ (x(2) - x(1)) * y(2);
plot(x_full, y_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);
xlabel('x', 'FontSize', 12);
ylabel('y(x)', 'FontSize', 12);
title('1st-Order Lagrange Interpolation', 'FontSize', 12);
grid on;
hold off;



%% Problem 3.2 2nd-order Lagrange Interpolation
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data set
x = [5, 12, 16];  
y = [1.609, 2.485, 2.773];

% Evaluation of Lagrange polynomial for x = 10
x_est = 10;
y_est = (x_est - x(2)) * (x_est - x(3)) / ((x(1) - x(2)) * (x(1) - x(3))) * y(1) + ...
        (x_est - x(1)) * (x_est - x(3)) / ((x(2) - x(1)) * (x(2) - x(3))) * y(2) + ...
        (x_est - x(1)) * (x_est - x(2)) / ((x(3) - x(1)) * (x(3) - x(2))) * y(3);

% Display the estimated value
fprintf('Estimated y at x = %.2f using 2nd-order Lagrange interpolation: %.4f\n', x_est, y_est);

% Plot
plot(x, y, 'ob', 'LineWidth', 2); hold on;
plot(x_est, y_est, 'xr', 'LineWidth', 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) .* (x_full - x(3)) ./ ((x(1) - x(2)) * (x(1) - x(3))) * y(1) + ...
           (x_full - x(1)) .* (x_full - x(3)) ./ ((x(2) - x(1)) * (x(2) - x(3))) * y(2) + ...
           (x_full - x(1)) .* (x_full - x(2)) ./ ((x(3) - x(1)) * (x(3) - x(2))) * y(3);
plot(x_full, y_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);
xlabel('x', 'FontSize', 12);
ylabel('y(x)', 'FontSize', 12);
title('2nd-Order Lagrange Interpolation', 'FontSize', 12);
grid on;
hold off;



%% Problem 3.3 3rd-order Lagrange Interpolation
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Data set
x = [5, 12, 16, 20];  
y = [1.609, 2.485, 2.773, 2.996];

% Evaluation of Lagrange polynomial for x = 10
x_est = 10;
y_est = (x_est - x(2)) * (x_est - x(3)) * (x_est - x(4)) / ((x(1) - x(2)) * (x(1) - x(3)) * (x(1) - x(4))) * y(1) + ...
        (x_est - x(1)) * (x_est - x(3)) * (x_est - x(4)) / ((x(2) - x(1)) * (x(2) - x(3)) * (x(2) - x(4))) * y(2) + ...
        (x_est - x(1)) * (x_est - x(2)) * (x_est - x(4)) / ((x(3) - x(1)) * (x(3) - x(2)) * (x(3) - x(4))) * y(3) + ...
        (x_est - x(1)) * (x_est - x(2)) * (x_est - x(3)) / ((x(4) - x(1)) * (x(4) - x(2)) * (x(4) - x(3))) * y(4);

% Display the estimated value
fprintf('Estimated y at x = %.2f using 3rd-order Lagrange interpolation: %.4f\n', x_est, y_est);

% Plot
plot(x, y, 'ob', 'LineWidth', 2); hold on;
plot(x_est, y_est, 'xr', 'LineWidth', 10);
x_full = linspace(5, 20, 100);
y_interp = (x_full - x(2)) .* (x_full - x(3)) .* (x_full - x(4)) ./ ((x(1) - x(2)) * (x(1) - x(3)) * (x(1) - x(4))) * y(1) + ...
           (x_full - x(1)) .* (x_full - x(3)) .* (x_full - x(4)) ./ ((x(2) - x(1)) * (x(2) - x(3)) * (x(2) - x(4))) * y(2) + ...
           (x_full - x(1)) .* (x_full - x(2)) .* (x_full - x(4)) ./ ((x(3) - x(1)) * (x(3) - x(2)) * (x(3) - x(4))) * y(3) + ...
           (x_full - x(1)) .* (x_full - x(2)) .* (x_full - x(3)) ./ ((x(4) - x(1)) * (x(4) - x(2)) * (x(4) - x(3))) * y(4);
plot(x_full, y_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1.5);
xlabel('x', 'FontSize', 12);
ylabel('y(x)', 'FontSize', 12);
title('3rd-Order Lagrange Interpolation', 'FontSize', 12);
grid on;
hold off;



%% Problem 4.1 2nd-order Interpolation via SLE
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Given Data (t P(t))
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
% Point of interest:
t_est = 18.5;
% Initialization of order of interpolation
Order = 2;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

% Perform interpolation
for k = Order:size(A,1)
    if A(k,1) >= t_est
        % Formulation of coefficient matrix R and vector of constants b
        for i = 1:Order+1
            for j = 1:Order+1
                R(i,j) = A(k+1-i,1)^(Order+1-j);
            end
            b(i) = A(k+1-i,2);
        end
        % Solution of system of equations via the inverse matrix
        coef = R\b;
        
        % Evaluation of interpolating polynomial
        for i = 1:size(coef,1)
            f = f + coef(i)*t_est^(Order+1-i);
        end
        
        fprintf('P(%.2f) = %.4f\n', t_est, f);
        break;
    end
end

% Plot
plot(t_est, f, 'rx', 'LineWidth', 10); hold on;
plot(A(:,1), A(:,2), 'ob', 'LineWidth', 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
for p = 1:length(t_full)
    for i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    end
end
plot(t_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1);
xlabel('Time t (s)');
ylabel('Position P(t) (cm)');
title('2nd-order Interpolation via SLE', 'FontSize', 12);
grid on;



%% Problem 4.2 3rd-order Interpolation via SLE
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Given Data (t P(t))
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
% Point of interest:
t_est = 18.5;
% Initialization of order of interpolation
Order = 3;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

% Perform interpolation
for k = Order:size(A,1)
    if A(k,1) >= t_est
        % Form matrix R and vector b
        for i = 1:Order+1
            for j = 1:Order+1
                R(i,j) = A(k+1-i,1)^(Order+1-j);
            end
            b(i) = A(k+1-i,2);
        end
        % Solution of system of equations via the inverse matrix
        coef = R\b;
        
        % Evaluation of interpolating polynomial
        for i = 1:size(coef,1)
            f = f + coef(i)*t_est^(Order+1-i);
        end
        
        fprintf('P(%.2f) = %.4f\n', t_est, f);
        break;
    end
end

% Plot
plot(t_est, f, 'rx', 'LineWidth', 10); hold on;
plot(A(:,1), A(:,2), 'ob', 'LineWidth', 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
for p = 1:length(t_full)
    for i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    end
end
plot(t_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1);
legend('Interpolated Value', 'Given Data', 'Interpolating Polynomial');
xlabel('Time t (s)');
ylabel('Position P(t) (cm)');
title('3rd-order Interpolation via SLE', 'FontSize', 12);
grid on;

%% Problem 4.3 7th-order Interpolation via SLE
%Clear previous workspace, screen, and close all figures:
clear
clc
close all

% Given Data (t P(t))
A = [0, 2.00; 2, 2.56; 6, 0.00; 8, -1.34; 10, -1.72; 16, 0.90; 20, 0.74; 22, 0.00];
% Point of interest:
t_est = 18.5;
% Initialization of order of interpolation
Order = 7;
R = zeros(Order+1, Order+1);
b = zeros(Order+1, 1);
f = 0;

% Formulation of coefficient matrix R and vector of constants b
for i = 1:Order+1
    for j = 1:Order+1
        R(i,j) = A(i,1)^(Order+1-j);
    end
    b(i) = A(i,2);
end

% Solution of system of equations via the inverse matrix
coef = R\b;

% Evaluation of interpolating polynomial
for i = 1:size(coef,1)
    f = f + coef(i)*t_est^(Order+1-i);
end
fprintf('P(%.2f) = %.4f\n', t_est, f);

% Plot
plot(t_est, f, 'rx', 'LineWidth', 10); hold on;
plot(A(:,1), A(:,2), 'ob', 'LineWidth', 2);
t_full = linspace(min(A(:,1)), max(A(:,1)), 100);
P_interp = zeros(size(t_full));
for p = 1:length(t_full)
    for i = 1:size(coef,1)
        P_interp(p) = P_interp(p) + coef(i) * t_full(p)^(Order+1-i);
    end
end
plot(t_full, P_interp, 'REPLACE_WITH_DASH_DASHk', 'LineWidth', 1);
legend('Interpolated Value', 'Given Data', 'Interpolating Polynomial');
xlabel('Time t (s)');
ylabel('Position P(t) (cm)');
title('7th-order Interpolation via SLE', 'FontSize', 12);
grid on;


%% Problem 4.4 Absolute True Percentage Errors
%Close all figures.
close all

% True value
P_true = 1.15;

% Estimates from Problems 4.1, 4.2, and 4.3
P_4_1 = 0.9788;  
P_4_2 = 1.3134;  
P_4_3 = 1.1184;  

% Calculate absolute true percentage errors
error_4_1 = abs((P_true - P_4_1) / P_true) * 100;
error_4_2 = abs((P_true - P_4_2) / P_true) * 100;
error_4_3 = abs((P_true - P_4_3) / P_true) * 100;

% Display the errors
fprintf('Absolute True Percentage Error for Problem 4.1: %.2f%%\n', error_4_1);
fprintf('Absolute True Percentage Error for Problem 4.2: %.2f%%\n', error_4_2);
fprintf('Absolute True Percentage Error for Problem 4.3: %.2f%%\n', error_4_3);

##### SOURCE END #####
-->
</body>
</html>
